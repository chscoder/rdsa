c!
team1
res
points
c!
c
hash = Hash[here.sort]
here.sort_by { |key, val| val}.to_h
here.sort_by { |key, val| val}
here
c
here.values.order_by { |p| p["P"] }
here.values.order
here.values
here
c
header
c
header
c
header
c
header
n
header
c!
c
n
c
res[1].values.map(&:to_s)
res[1].values.map(&:to_s).join(" ")
res[1].values.map(&:to_s).join(",")
res[1].values.map(&:to_s).join(" ")
res[1].values.map(&:to_s)
res[1].values.map(&to_s)
res[1].values.map(:&to_s)
res[1].values
res[1].values.join(',')
res[1].values.join('"",')
res[1].values.join('""\n,')
res[1].values.join('""')
res[1].values.join(',')
res
res[1].values.join(',')
res[0]
FORMAT
"#{sprintf(FORMAT,res[0],res[1].values.join(','))}\n"
c
header
c
header
c
header
c
header
c
header
c!
C!
input
sprintf("Team", "MP", "W",  "D", "L", "P")
"#{sprintf("Team", "MP", "W",  "D", "L", "P")}"
header
c!
header
n
header
n
input == "\n"
input
c
input.chars
input.char
input
input.any?
input.blank?
input
n
input
c
input
header
c!
header
c
header
c!
c
header
c!
c
header
c!
res[1].values.join(" | ")
res[1].values.join
res[1].values
res[1]
res[0]
res
c!
h
c!
C
self.parse_input(input.split("\n")).map { |a| a[1]["MP"] }
self.parse_input(input.split("\n")).map { |a| a[1] }
self.parse_input(input.split("\n")).map { |a| a[0] }
self.parse_input(input.split("\n")).map { |a| a }
self.parse_input(input.split("\n"))
n
memo
n
result
n
res
team2
team1
c!
input.split("\n")
input.split(" \n")
input.split(" \;")
input.split(";\")
input.split("\")
input.split("\ ;")
input.split("\; ")
input.split("\;")
input.split("\")
input.split("z")
input
input.split(";")
input.split("\;")
input.split("\n")
input.split('\n')
input
c!
c
input
memo
input
line
res
line
team2
team1
c!
c
self.parse_input(input.split("\;"))
c
self.parse_input(input.split("\;"))
c
self.parse_input(input.split("\;"))
a
self.parse_input(input.split("\;")).each { |a| a }
self.parse_input(input.split("\;")).each { |a| a.first }
self.parse_input(input.split("\;")).each { |a| a[0] }
self.parse_input(input.split("\;")).each { |a| a.keys }
self.parse_input(input.split("\;")).each { |a| a.key }
self.parse_input(input.split("\;")).each { |a| a }
self.parse_input(input.split("\;"))
header
self.parse_input(input.split("\;"))
c!
c
n
input
c
result
n
input
c!
c
c!
c
n
input
c
input
c
input
c!
self.parse_input(input.split("\n"))
c!
c
c!
memo
c!
c
result
c
result
self.result
c
memo
c!
self.result
self
self.result
self
c!
c
    input.split("\n").each_with_object({}) do |line, memo|
      team1, team2, result = line.split("\;")
      memo[team1] ||= { 'MP' => 0, 'W' => 0, 'D' => 0, 'L' => 0, 'P' => 0 }
    end
c
    input.split("\n").each_with_object({}) do |line, memo|
      team1, team2, result = line.split("\;")
      memo[team1] ||= { 'MP' => 0, 'W' => 0, 'D' => 0, 'L' => 0, 'P' => 0 }
    end
c!
c
obj
c!
c
    input.split("\n").each_with_object({}) do |line, hash|
c
    input.split("\n").each_with_object({}) do |line, hash|
      byebug
      team1, team2, result = line.split("\;")
    end
line.split("\;")
c
line.split("\;")
c
line.split
line[0]
line
line.split(";")
line
line.to_r
line.to_a
line
line.split("line")
line.split(".")
line.split(";")
line.split(" ")
line.split("")
line.split(";")
line.split("; ")
line.split('; ')
line.split(' ;')
line.split(' ; ')
line.split(';')
line.split(";")
line.split(" ")
line.split("")
line.split(";")
line.split(",")
line.split(";")
line
team1, team2, result = line.split(";")
line
c!
    input.split("\n").each_with_object({}) do |line, hash|
      team1, team2, result = line.split(";")
    end
c!
